# Yongqin Jian
# 1472458
import numpy as np
import torch
import torch.nn as nn
import torch.utils.data as utils
import torch.nn.functional as F


def classify_and_detect(images):
    """
    :param np.ndarray images: N x 4096 array containing N 64x64 images flattened into vectors
    :return: np.ndarray, np.ndarray
    """
    N = images.shape[0]

    # pred_class: Your predicted labels for the 2 digits, shape [N, 2]
    pred_class = np.empty((N, 2), dtype=np.int32)

    # pred_bboxes: Your predicted bboxes for 2 digits, shape [N, 2, 4]
    pred_bboxes = np.empty((N, 2, 4), dtype=np.float64)
    
    
    #run_train(pred_class,pred_bboxes) # train the model from given data

    # I re-defined my model classes and other in order to work without error
    # set up some parameters being used further
    class TrainParams:
      def __init__(self):
          #self.batch_size = 100
          #self.n_epochs = 20
          self.weights_path = './model.pt'
    class BlockNet(nn.Module):
          def __init__(self, in_channels, out_channels, stride):
              super(BlockNet, self).__init__()
              self.layer = nn.Sequential()
              self.layer.add_module("Conv", nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=3, stride=stride, padding=1))
              self.layer.add_module("Bn", nn.BatchNorm2d(out_channels))
              self.skip = nn.Sequential()
              if stride != 1 or in_channels != out_channels:
                  self.skip = nn.Sequential()
                  self.skip.add_module("Conv", nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=3, stride=stride, padding=1))
                  self.skip.add_module("Bn", nn.BatchNorm2d(out_channels))
          def forward(self, x):
              out = self.layer(x)
              out += self.skip(x)
              return F.relu(out)
    class ResNet(nn.Module):
      def __init__(self, bk):
          super(ResNet, self).__init__()
          self.layer1 = nn.Sequential()
          self.layer1.add_module("Conv", nn.Conv2d(in_channels=1, out_channels=64, kernel_size=3, padding=1))
          self.layer1.add_module("Bn", nn.BatchNorm2d(64))
          self.layer1.add_module("Relu", nn.ReLU(True))
          self.pool = nn.AvgPool2d(kernel_size=4, stride=4)
          self.layer2 = nn.Sequential(bk(64, 64, 1),bk(64, 64, 1),)
          self.layer4 = nn.Sequential(bk(64, 128, 2),bk(128, 128, 1),)
          self.layer5 = nn.Sequential(bk(128, 256, 2),bk(256, 256, 1),)
          self.layer6 = nn.Sequential(bk(256, 512, 2),bk(512, 512, 1),)
          self.layer7 = nn.Sequential(bk(512, 1024, 2),bk(1024, 1024, 1),)
          self.linear = nn.Sequential(nn.Dropout(p=0.5),nn.Linear(1024, 512),nn.ReLU(True),nn.Linear(512, 37*4+20),)
      def forward(self, x):
          x = self.layer1(x)
          x = self.layer2(x)
          x = self.layer4(x)
          x = self.layer5(x)
          x = self.layer6(x)
          x = self.layer7(x)
          x = self.pool(x)
          x = x.view(x.size(0), -1)
          x = self.linear(x)
          cls = x[:,0:20]
          bb1 = x[:,20:]
          return cls.view(-1, 10, 2), bb1.view(-1, 4, 37)



    # The Testing part Starts here
    param = TrainParams()
    print("Loading Model...")
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model=ResNet(BlockNet)
    model.load_state_dict(torch.load(param.weights_path,map_location=torch.device('cpu')))
    if torch.cuda.is_available():
      model.to(device)
    if torch.cuda.is_available():
      print('Testing on GPU: {}'.format(torch.cuda.get_device_name(0)))
    else:
        print('Using CPU instead')
    
    model.eval()
    with torch.no_grad():
      for i, image in enumerate(images):
        # Converting flatten images into normal image 64x64
        image = torch.Tensor(image).view(1, 1, 64, 64)
        image = image.to(device)
        cls, bb1 = model(image) # both prediction are generated by same model
        cls = torch.sort(cls)[0]  # sort the pred_classification in ascending order
        pred_cls = torch.max(cls.data, 1)[1]  
        pred_class[i] = pred_cls.cpu().detach().numpy()
        
        bb1_pred = torch.max(bb1[:,0,:].data, 1)[1]
        bb2_pred = torch.max(bb1[:,1,:].data, 1)[1]
        bb3_pred = torch.max(bb1[:,2,:].data, 1)[1]
        bb4_pred = torch.max(bb1[:,3,:].data, 1)[1]

        # placeholder for bounding box index
        b_box = np.empty((2, 4))

        # the first bounding box
        b_box[0][0] = bb1_pred
        b_box[0][1] = bb2_pred
        b_box[0][2] = bb1_pred+28 # since the bottom right is 28 unit away from top left
        b_box[0][3] = bb2_pred+28

        # the second bounding box
        b_box[1][0] = bb3_pred
        b_box[1][1] = bb4_pred
        b_box[1][2] = bb3_pred+28
        b_box[1][3] = bb4_pred+28

        pred_bboxes[i] = b_box

    return pred_class, pred_bboxes

 